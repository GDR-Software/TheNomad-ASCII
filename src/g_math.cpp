//----------------------------------------------------------
//
// Copyright (C) SIGAAMDAD 2022-2023
//
// This source is available for distribution and/or modification
// only under the terms of the SACE Source Code License as
// published by SIGAAMDAD. All rights reserved
//
// The source is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of FITNESS FOR A PARTICLAR PURPOSE. See the SACE
// Source Code License for more details. If you, however do not
// want to use the SACE Source Code License, then you must use
// this source as if it were to be licensed under the GNU General
// Public License (GPL) version 2.0 or later as published by the
// Free Software Foundation.
//
// DESCRIPTION:
//  src/g_math.cpp
//----------------------------------------------------------
#include "n_shared.h"

#include <bit>
#include <limits.h>

/*
* this algorithm was improved over the many months of this game's development.
* originally, it didn't compute distance between diagonal objects, only vertical and horizontal
* but now, thanks to my friend Catazat, it does, using the pythagorean theorem.
*
* note: some small optimizations have been made to the release mode
*
* another note: I thought up this algo in math class, freshmen year, when i should have been doing algebra,
* but i have zero regrets
*/
inline nomadint_t disBetweenOBJ(const coord_t src, const coord_t tar)
{
	if (src.y == tar.y) { // horizontal
#ifdef _NOMAD_DEBUG
		if (src.x > tar.x) {
			LOG("distance is horizontal, src.x is greater than tar.x, distance between objects is %i", src.x - tar.x);
			return (src.x - tar.x);
		}
		else if (src.x < tar.x) {
			LOG("distance is horizontal, src.x is less than tar.x, distance between objects is %i", tar.x - src.x);
			return (tar.x - src.x);
		}
		else {
			LOG("distance is horziontal, src.x is equal to tar.x, returning 0");
			return 0;
		}
#else
		return src.x > tar.x ? (src.x - tar.x) : (tar.x - src.x);
#endif
	}
	else if (src.x == tar.x) { // vertical
#ifdef _NOMAD_DEBUG
		if (src.y > tar.y) {
			LOG("distance is vertical, src.y is greater than tar.y, distance between objects is %i", src.y - tar.y);
			return (src.y - tar.y);
		}
		else if (src.y < tar.y) {
			LOG("distance is vertical, src.y is less than tar.y, distance between objects is %i", tar.y - src.y);
			return (tar.y - src.y);
		}
		else {
			LOG("distance is vertical, src.y is equal to tar.y, returning 0");
			return 0;
		}
#else
		return src.y > tar.y ? (src.y - tar.y) : (tar.y - src.y);
#endif
	}
	else { // diagonal
#ifdef _NOMAD_DEBUG
		// don't want to be do the calculations twice, assign it to a variable
		nomadint_t r = abs(Q_root((pow((src.x - tar.x), 2) + pow((src.y - tar.y), 2))));
		LOG("distance is diagonal, returning pythagorian theorem, result: %i", r);
		return r;
#else
		return abs(Q_root((pow((src.x - tar.x), 2) + pow((src.y - tar.y), 2))));
#endif
	}
}

inline bool coord_t::operator==(struct coord_s c) const {
	return (y == c.y && x == c.x);
}
inline bool coord_t::operator<(struct coord_s c) const {
	return (y < c.y && x < c.x);
}
inline bool coord_t::operator>(struct coord_s c) const {
	return (y > c.y && x > c.x);
}
inline bool coord_t::operator>=(struct coord_s c) const {
	return (y >= c.y && x >= c.x);
}
inline bool coord_t::operator<=(struct coord_s c) const {
	return (y <= c.y && x <= c.x);
}
inline bool coord_t::operator!=(struct coord_s c) const {
	return (y != c.y && x != c.x);
}

// NOTE: some of this algo was generated by ChatGPT, although heavily modified and changed up by me
coord_t closestOBJ(const std::vector<coord_t>& coords, const coord_t src)
{
	// Initialize minimum distance to a large number
	nomaduint_t mindis = std::numeric_limits<nomaduint_t>::max();
	coord_t closest;
	// Iterate through the vector and find the closest coordinates
	for (const coord_t& coord : coords) {
		nomaduint_t dis = disBetweenOBJ(coord, src);
		if (dis < mindis) {
			mindis = dis;
			closest = coord;
		}
	}
	return closest;
}

static constexpr float threehalfs = 1.5f;

// inspired heavly from Q3 Fast Inverse Square Root algorithm
// quick square root, because normal sqrts are too slow for me
inline nomadfloat_t Q_root(nomadfloat_t x)
{
	nomadlong_t        i;								// The integer interpretation of x
	nomadfloat_t       x_half = x * 0.5f;
	nomadfloat_t       r_sqrt = x;
#ifdef _NOMAD_DEBUG
	if (!(x > 0) || std::isnan(x) || std::isinf(x))
		return std::numeric_limits<nomadfloat_t>::quiet_NaN();
	
	i = *reinterpret_cast<int64_t*>(&r_sqrt);
	i = 0x5f375a86 - (i >> 1);
	r_sqrt = *reinterpret_cast<nomadfloat_t*>(&i);
#else
	// trick c/c++, bit hack
	i = *(nomadlong_t *)&r_sqrt;					    // oh yes, undefined behaviour, who gives a fuck?
	i = 0x5f375a86 - (i >> 1);				            // weird magic base-16 nums
	r_sqrt = *(nomadfloat_t *) &i;
#endif
	r_sqrt = r_sqrt * (threehalfs - (x_half * r_sqrt * r_sqrt)); // 1st Newton iteration
	r_sqrt = r_sqrt * (threehalfs - (x_half * r_sqrt * r_sqrt)); // 2nd Newton iteration

	return x * r_sqrt; // x * (1/sqrt(x)) := sqrt(x)
}
