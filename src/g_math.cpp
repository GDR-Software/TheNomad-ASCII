//----------------------------------------------------------
//
// Copyright (C) SIGAAMDAD 2022-2023
//
// This source is available for distribution and/or modification
// only under the terms of the SACE Source Code License as
// published by SIGAAMDAD. All rights reserved
//
// The source is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of FITNESS FOR A PARTICLAR PURPOSE. See the SACE
// Source Code License for more details. If you, however do not
// want to use the SACE Source Code License, then you must use
// this source as if it were to be licensed under the GNU General
// Public License (GPL) version 2.0 or later as published by the
// Free Software Foundation.
//
// DESCRIPTION:
//  src/g_math.cpp
//----------------------------------------------------------
#include "n_shared.h"

/*
* this algorithm was improved over the many months of this game's development.
* originally, it didn't compute distance between diagonal objects, only vertical and horizontal
* but now, thanks to my friend Catazat, it does, using the pythagorean theorem.
*/
nomaduint_t disBetweenOBJ(const coord_t src, const coord_t tar)
{
	if (src.y == tar.y) { // horizontal
		if (src.x > tar.x) { return (src.x - tar.x);}
		else if (src.x < tar.x) { return (tar.x - src.x); }
		else { return 0; }
	}
	else if (src.x == tar.x) { // vertical
		if (src.y > tar.y) { return (src.y - tar.y); }
		else if (src.y < tar.y) { return (tar.y - src.y); }
		else { return 0; }
	}
	else { // diagonal
		return abs(sqrt(pow((src.x - tar.x), 2) - pow((src.y - tar.y), 2)));
	}
}

// NOTE: some of this algo was generated by ChatGPT, although heavily modified and changed up by me
coord_t closestOBJ(const std::vector<coord_t>& coords, const coord_t src)
{
	// Initialize minimum distance to a large number
	nomaduint_t mindis = std::numeric_limits<nomaduint_t>::max();
	coord_t closest;
	// Iterate through the vector and find the closest coordinates
	for (const coord_t& coord : coords) {
		nomaduint_t dis = disBetweenOBJ(coord, src);
		if (dis < mindis) {
			mindis = dis;
			closest = coord;
		}
	}
	return closest;
}

static constexpr float threehalfs = 1.5f;

// inspired heavly from Q3 Fast Inverse Square Root algorithm
// quick square root, because normal sqrts are too slow for me
nomadfloat_t Q_root(nomadfloat_t x)
{
	nomadlong_t        i;								// The integer interpretation of x
	nomadfloat_t       x_half = x * 0.5f;
	nomadfloat_t       r_sqrt = x;

	// trick c/c++, bit hack
	i = *(nomadlong_t *)&r_sqrt;					    // oh yes, undefined behaviour, who gives a fuck?
	i = 0x5f375a86 - (i >> 1);				            // weird magic base-16 nums
	r_sqrt = *(nomadfloat_t *) &i;

	r_sqrt = r_sqrt * (threehalfs - (x_half * r_sqrt * r_sqrt)); // 1st Newton iteration
	r_sqrt = r_sqrt * (threehalfs - (x_half * r_sqrt * r_sqrt)); // 2nd Newton iteration

	return x * r_sqrt; // x * (1/sqrt(x)) := sqrt(x)
}